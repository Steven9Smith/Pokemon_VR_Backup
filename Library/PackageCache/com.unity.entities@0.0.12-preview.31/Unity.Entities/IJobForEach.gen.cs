//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated by T4 (TextTransform.exe) from the file IJobForEach.tt 
//

using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using System.Runtime.InteropServices;
using UnityEngine.Scripting;
using System;

namespace Unity.Entities
{

#if !UNITY_DOTSPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_D<,>))]
#endif
    public interface IJobForEach<U0> : JobForEachExtensions.IBaseJobForEach_D
            where U0 : struct, IComponentData
    {
        void Execute(ref U0 c0);
    }

#if !UNITY_DOTSPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ED<,>))]
#endif
    public interface IJobForEachWithEntity<U0> : JobForEachExtensions.IBaseJobForEach_ED
            where U0 : struct, IComponentData
    {
        void Execute(Entity entity, int index, ref U0 c0);
    }

#if !UNITY_DOTSPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_DD<,,>))]
#endif
    public interface IJobForEach<U0, U1> : JobForEachExtensions.IBaseJobForEach_DD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
    {
        void Execute(ref U0 c0, ref U1 c1);
    }

#if !UNITY_DOTSPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EDD<,,>))]
#endif
    public interface IJobForEachWithEntity<U0, U1> : JobForEachExtensions.IBaseJobForEach_EDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
    {
        void Execute(Entity entity, int index, ref U0 c0, ref U1 c1);
    }

#if !UNITY_DOTSPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_DDD<,,,>))]
#endif
    public interface IJobForEach<U0, U1, U2> : JobForEachExtensions.IBaseJobForEach_DDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
    {
        void Execute(ref U0 c0, ref U1 c1, ref U2 c2);
    }

#if !UNITY_DOTSPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EDDD<,,,>))]
#endif
    public interface IJobForEachWithEntity<U0, U1, U2> : JobForEachExtensions.IBaseJobForEach_EDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
    {
        void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2);
    }

#if !UNITY_DOTSPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_DDDD<,,,,>))]
#endif
    public interface IJobForEach<U0, U1, U2, U3> : JobForEachExtensions.IBaseJobForEach_DDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
    {
        void Execute(ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3);
    }

#if !UNITY_DOTSPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EDDDD<,,,,>))]
#endif
    public interface IJobForEachWithEntity<U0, U1, U2, U3> : JobForEachExtensions.IBaseJobForEach_EDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
    {
        void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3);
    }

#if !UNITY_DOTSPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_DDDDD<,,,,,>))]
#endif
    public interface IJobForEach<U0, U1, U2, U3, U4> : JobForEachExtensions.IBaseJobForEach_DDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
    {
        void Execute(ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4);
    }

#if !UNITY_DOTSPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EDDDDD<,,,,,>))]
#endif
    public interface IJobForEachWithEntity<U0, U1, U2, U3, U4> : JobForEachExtensions.IBaseJobForEach_EDDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
    {
        void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4);
    }

#if !UNITY_DOTSPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_DDDDDD<,,,,,,>))]
#endif
    public interface IJobForEach<U0, U1, U2, U3, U4, U5> : JobForEachExtensions.IBaseJobForEach_DDDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
    {
        void Execute(ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4, ref U5 c5);
    }

#if !UNITY_DOTSPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EDDDDDD<,,,,,,>))]
#endif
    public interface IJobForEachWithEntity<U0, U1, U2, U3, U4, U5> : JobForEachExtensions.IBaseJobForEach_EDDDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
    {
        void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4, ref U5 c5);
    }

    public static partial class JobForEachExtensions
    { 
#if !UNITY_DOTSPLAYER                           
        public static JobHandle Schedule<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_D).IsAssignableFrom(typeT))
                return ScheduleInternal_D(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ED).IsAssignableFrom(typeT))
                return ScheduleInternal_ED(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DD).IsAssignableFrom(typeT))
                return ScheduleInternal_DD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_DOTSPLAYER                           
        public static JobHandle ScheduleSingle<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_D).IsAssignableFrom(typeT))
                return ScheduleInternal_D(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ED).IsAssignableFrom(typeT))
                return ScheduleInternal_ED(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DD).IsAssignableFrom(typeT))
                return ScheduleInternal_DD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_DOTSPLAYER                           
        public static JobHandle Run<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_D).IsAssignableFrom(typeT))
                return ScheduleInternal_D(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ED).IsAssignableFrom(typeT))
                return ScheduleInternal_ED(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DD).IsAssignableFrom(typeT))
                return ScheduleInternal_DD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            throw new System.ArgumentException("Not supported");
        }
#endif

#if !UNITY_DOTSPLAYER                           
        public static JobHandle Schedule<T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_D).IsAssignableFrom(typeT))
                return ScheduleInternal_D(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ED).IsAssignableFrom(typeT))
                return ScheduleInternal_ED(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DD).IsAssignableFrom(typeT))
                return ScheduleInternal_DD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDDD(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_DOTSPLAYER                           
        public static JobHandle ScheduleSingle<T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_D).IsAssignableFrom(typeT))
                return ScheduleInternal_D(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ED).IsAssignableFrom(typeT))
                return ScheduleInternal_ED(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DD).IsAssignableFrom(typeT))
                return ScheduleInternal_DD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_DDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EDDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_DOTSPLAYER                           
        public static JobHandle Run<T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_D).IsAssignableFrom(typeT))
                return ScheduleInternal_D(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ED).IsAssignableFrom(typeT))
                return ScheduleInternal_ED(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DD).IsAssignableFrom(typeT))
                return ScheduleInternal_DD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_DDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_DDDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EDDDDDD).IsAssignableFrom(typeT))
                return ScheduleInternal_EDDDDDD(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            throw new System.ArgumentException("Not supported");
        }
#endif

#if !UNITY_DOTSPLAYER           
        internal static unsafe JobHandle ScheduleInternal_D<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_D<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_D<,>), isParallelFor, ref JobStruct_ProcessInfer_D<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_D<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_D<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_D : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_D<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_D<T, U0>
            where T : struct, IJobForEach<U0>
            where U0 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_D<T, U0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_D<T, U0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_D<T, U0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_D<T, U0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER           
        internal static unsafe JobHandle ScheduleInternal_ED<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_ED<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_ED<,>), isParallelFor, ref JobStruct_ProcessInfer_ED<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_ED<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ED<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_ED : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_ED<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_ED<T, U0>
            where T : struct, IJobForEachWithEntity<U0>
            where U0 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ED<T, U0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_ED<T, U0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_ED<T, U0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_ED<T, U0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER           
        internal static unsafe JobHandle ScheduleInternal_DD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_DD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_DD<,,>), isParallelFor, ref JobStruct_ProcessInfer_DD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_DD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_DD : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_DD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_DD<T, U0, U1>
            where T : struct, IJobForEach<U0, U1>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DD<T, U0, U1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_DD<T, U0, U1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_DD<T, U0, U1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_DD<T, U0, U1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER           
        internal static unsafe JobHandle ScheduleInternal_EDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EDD<,,>), isParallelFor, ref JobStruct_ProcessInfer_EDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EDD : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EDD<T, U0, U1>
            where T : struct, IJobForEachWithEntity<U0, U1>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDD<T, U0, U1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EDD<T, U0, U1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EDD<T, U0, U1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EDD<T, U0, U1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER           
        internal static unsafe JobHandle ScheduleInternal_DDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_DDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_DDD<,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_DDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_DDD : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_DDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_DDD<T, U0, U1, U2>
            where T : struct, IJobForEach<U0, U1, U2>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDD<T, U0, U1, U2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_DDD<T, U0, U1, U2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_DDD<T, U0, U1, U2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_DDD<T, U0, U1, U2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER           
        internal static unsafe JobHandle ScheduleInternal_EDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EDDD<,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EDDD : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EDDD<T, U0, U1, U2>
            where T : struct, IJobForEachWithEntity<U0, U1, U2>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDD<T, U0, U1, U2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EDDD<T, U0, U1, U2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EDDD<T, U0, U1, U2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EDDD<T, U0, U1, U2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER           
        internal static unsafe JobHandle ScheduleInternal_DDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_DDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_DDDD<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_DDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_DDDD : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_DDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_DDDD<T, U0, U1, U2, U3>
            where T : struct, IJobForEach<U0, U1, U2, U3>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDDD<T, U0, U1, U2, U3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_DDDD<T, U0, U1, U2, U3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_DDDD<T, U0, U1, U2, U3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_DDDD<T, U0, U1, U2, U3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                    var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER           
        internal static unsafe JobHandle ScheduleInternal_EDDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EDDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EDDDD<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EDDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EDDDD : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EDDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EDDDD<T, U0, U1, U2, U3>
            where T : struct, IJobForEachWithEntity<U0, U1, U2, U3>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDDD<T, U0, U1, U2, U3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EDDDD<T, U0, U1, U2, U3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EDDDD<T, U0, U1, U2, U3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EDDDD<T, U0, U1, U2, U3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                    var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER           
        internal static unsafe JobHandle ScheduleInternal_DDDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_DDDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_DDDDD<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_DDDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_DDDDD : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_DDDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4>
            where T : struct, IJobForEach<U0, U1, U2, U3, U4>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 
                        var typeLookupCache4 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                    var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
                    var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER           
        internal static unsafe JobHandle ScheduleInternal_EDDDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EDDDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EDDDDD<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EDDDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EDDDDD : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EDDDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4>
            where T : struct, IJobForEachWithEntity<U0, U1, U2, U3, U4>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 
                        var typeLookupCache4 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                    var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
                    var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER           
        internal static unsafe JobHandle ScheduleInternal_DDDDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_DDDDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_DDDDDD<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDDDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_DDDDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DDDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_DDDDDD : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_DDDDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5>
            where T : struct, IJobForEach<U0, U1, U2, U3, U4, U5>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 
                        var typeLookupCache4 = 0; 
                        var typeLookupCache5 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                    var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
                    var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
                    var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<U5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER           
        internal static unsafe JobHandle ScheduleInternal_EDDDDDD<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EDDDDDD<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EDDDDDD<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDDDDD<T>.Cache, out fullData.Iterator);
                
            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EDDDDDD<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDDDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EDDDDDD : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EDDDDDD<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5>
            where T : struct, IJobForEachWithEntity<U0, U1, U2, U3, U4, U5>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;
            
            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 
                        var typeLookupCache4 = 0; 
                        var typeLookupCache5 = 0; 

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {    
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                    var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                    var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                    var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                    var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
                    var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
                    var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));
  

                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<U5>(ptr5, i));
                    }
                }
            }
        }
#endif


#if UNITY_DOTSPLAYER
        internal unsafe static JobHandle Schedule_Query_rD<TJob, T0>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0>
            where T0 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wD<TJob, T0>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0>
            where T0 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErD<TJob, T0>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0>
            where T0 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwD<TJob, T0>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0>
            where T0 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index, 
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

#endif
    }
}

